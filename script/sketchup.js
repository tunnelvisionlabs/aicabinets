#!/usr/bin/env node
const fs = require('fs');
const os = require('os');
const path = require('path');
const { spawn } = require('child_process');

const repoRoot = path.resolve(__dirname, '..');
const sketchupVersion = process.env.SKETCHUP_VERSION || '2026';
const defaultExeBase = process.env.ProgramFiles || 'C:\\Program Files';
const defaultExe = path.win32.join(
  defaultExeBase,
  'SketchUp',
  `SketchUp ${sketchupVersion}`,
  'SketchUp',
  'SketchUp.exe',
);
const defaultPlugins = process.env.APPDATA
  ? path.win32.join(process.env.APPDATA, 'SketchUp', `SketchUp ${sketchupVersion}`, 'SketchUp', 'Plugins')
  : null;

function parseArgs(argv) {
  const args = { flags: {} };
  const [, , command, ...rest] = argv;
  args.command = command;

  for (let i = 0; i < rest.length; i += 1) {
    const token = rest[i];
    if (!token.startsWith('--')) continue;
    const key = token.slice(2);
    const next = rest[i + 1];
    if (next && !next.startsWith('--')) {
      args.flags[key] = next;
      i += 1;
    } else {
      args.flags[key] = true;
    }
  }
  return args;
}

function ensureAbsolute(inputPath) {
  if (path.isAbsolute(inputPath) || path.win32.isAbsolute(inputPath)) {
    return inputPath;
  }
  return path.resolve(repoRoot, inputPath);
}

function ensureExists(targetPath, label) {
  if (!targetPath) {
    throw new Error(`Missing ${label}. Set the related environment variable to override the default.`);
  }
  if (!fs.existsSync(targetPath)) {
    throw new Error(`${label} not found: ${targetPath}`);
  }
}

function logDebug(enabled, message) {
  if (enabled) {
    console.log(`[debug] ${message}`);
  }
}

function copyExtension(pluginsDir, debug) {
  logDebug(debug, `Ensuring Plugins directory exists: ${pluginsDir}`);
  fs.mkdirSync(pluginsDir, { recursive: true });

  const registrarSrc = path.join(repoRoot, 'aicabinets.rb');
  const registrarDst = path.join(pluginsDir, 'aicabinets.rb');
  ensureExists(registrarSrc, 'aicabinets.rb');

  logDebug(debug, `Copying registrar to ${registrarDst}`);
  fs.copyFileSync(registrarSrc, registrarDst);

  const supportSrc = path.join(repoRoot, 'aicabinets');
  const supportDst = path.join(pluginsDir, 'aicabinets');
  ensureExists(supportSrc, 'aicabinets/');

  logDebug(debug, `Refreshing support folder at ${supportDst}`);
  fs.rmSync(supportDst, { recursive: true, force: true });
  fs.cpSync(supportSrc, supportDst, { recursive: true });
}

function runSketchUp(exePath, args, debug, { capture = false } = {}) {
  return new Promise((resolve, reject) => {
    logDebug(debug, `Launching SketchUp: ${exePath} ${args.map((arg) => JSON.stringify(arg)).join(' ')}`);

    const child = spawn(exePath, args, {
      stdio: capture ? ['ignore', 'pipe', 'pipe'] : 'inherit',
    });

    const stdoutChunks = [];
    const stderrChunks = [];

    if (capture && child.stdout && child.stderr) {
      child.stdout.on('data', (data) => {
        stdoutChunks.push(data);
        process.stdout.write(data);
      });
      child.stderr.on('data', (data) => {
        stderrChunks.push(data);
        process.stderr.write(data);
      });
    }

    child.on('error', (error) => {
      reject(new Error(`Failed to launch SketchUp: ${error.message}`));
    });

    child.on('exit', (code) => {
      const stdout = Buffer.concat(stdoutChunks).toString();
      const stderr = Buffer.concat(stderrChunks).toString();

      if (code !== 0) {
        reject(new Error(`SketchUp exited with status ${code}\n${stdout}${stderr ? `\n${stderr}` : ''}`));
      } else {
        resolve({ stdout, stderr });
      }
    });
  });
}

function resolvedPaths(flags) {
  const debug = Boolean(flags.debug);
  const sketchupExe = flags.exe ? ensureAbsolute(flags.exe) : (process.env.SKETCHUP_EXE || defaultExe);
  const pluginsDir = flags.plugins ? ensureAbsolute(flags.plugins) : (process.env.SKETCHUP_PLUGINS_DIR || defaultPlugins);
  const testsRoot = flags.tests ? ensureAbsolute(flags.tests) : (process.env.AI_CABINETS_TESTS || path.join(repoRoot, 'tests', 'AI Cabinets'));

  return { sketchupExe, pluginsDir, testsRoot, debug };
}

function renderWrapper(startupScript) {
  return `# Auto-generated by script/sketchup.js\n\n` +
`def close_without_save\n` +
`  if defined?(Sketchup.close_active_model)\n` +
`    Sketchup.close_active_model(false)\n` +
`  else\n` +
`    model = Sketchup.active_model\n` +
`    if model&.respond_to?(:close)\n` +
`      model.close(false)\n` +
`    end\n` +
`  end\n` +
`rescue => error\n` +
`  STDERR.puts("Close failure: #{error.message}")\n` +
`  error.backtrace.each { |line| STDERR.puts(line) }\n` +
`end\n\n` +
`begin\n` +
`  load '${startupScript.replace(/\\/g, '\\\\')}'\n` +
`rescue => error\n` +
`  STDERR.puts("Script error: #{error.message}")\n` +
`  error.backtrace.each { |line| STDERR.puts(line) }\n` +
`end\n\n` +
`begin\n` +
`  close_without_save\n` +
`ensure\n` +
`  Sketchup.quit\n` +
`end\n`;
}

function parseOutputHint(configPath) {
  try {
    const content = fs.readFileSync(configPath, 'utf8');
    const match = content.match(/^Output:\s*(.+)$/mi);
    if (match) {
      return match[1].trim();
    }
  } catch (error) {
    // Best-effort logging only.
  }
  return null;
}

async function deploy(paths) {
  ensureExists(paths.sketchupExe, 'SketchUp executable');
  ensureExists(paths.pluginsDir, 'SketchUp Plugins directory (set SKETCHUP_PLUGINS_DIR or APPDATA)');
  copyExtension(paths.pluginsDir, paths.debug);
  console.log(`Deployed AI Cabinets to ${paths.pluginsDir}`);
}

async function runTestUpAll(paths) {
  await deploy(paths);
  ensureExists(paths.testsRoot, 'AI Cabinets TestUp suite');
  console.log(`Running TestUp suite from ${paths.testsRoot}`);
  const arg = `TestUp:CI:Path: ${paths.testsRoot}`;
  await runSketchUp(
    paths.sketchupExe,
    ['-RubyStartupArg', arg],
    paths.debug,
    { capture: true },
  );
  console.log('TestUp suite completed.');
}

async function runTestUpConfig(paths, configPath) {
  await deploy(paths);
  const resolvedConfig = ensureAbsolute(configPath || process.env.TESTUP_CONFIG || '');
  ensureExists(resolvedConfig, 'TestUp config file');
  const outputHint = parseOutputHint(resolvedConfig);
  if (outputHint) {
    console.log(`Config output path: ${outputHint}`);
  }
  const arg = `TestUp:CI:Config: ${resolvedConfig}`;
  console.log(`Running TestUp config from ${resolvedConfig}`);
  await runSketchUp(
    paths.sketchupExe,
    ['-RubyStartupArg', arg],
    paths.debug,
    { capture: true },
  );
  if (outputHint) {
    console.log(`Results should be written to: ${outputHint}`);
  }
}

function generateClassConfig(testsRoot, testClass, outputPath, debug) {
  if (!testClass) {
    throw new Error('Missing required --class <TestUpClassName> argument.');
  }
  ensureExists(testsRoot, 'AI Cabinets TestUp suite');

  const safeName = testClass.replace(/[^A-Za-z0-9_-]/g, '_');
  const configPath = path.join(os.tmpdir(), `aicabinets-class-${safeName}-${Date.now()}.yml`);
  const resolvedOutput = ensureAbsolute(
    outputPath || path.join(repoRoot, 'dist', `testup-${safeName}-results.json`),
  );

  fs.mkdirSync(path.dirname(resolvedOutput), { recursive: true });

  const content = [
    `Path: ${testsRoot}`,
    `Output: ${resolvedOutput}`,
    'Tests:',
    `  - ${testClass}#`,
    '',
  ].join('\n');

  fs.writeFileSync(configPath, content, 'utf8');
  logDebug(debug, `Generated class config at ${configPath}`);
  logDebug(debug, `Results will be written to ${resolvedOutput}`);
  return { configPath, resolvedOutput };
}

async function runTestUpClass(paths, testClass, outputPath) {
  const resolvedClass = testClass || process.env.TESTUP_CLASS;
  const { configPath, resolvedOutput } = generateClassConfig(
    paths.testsRoot,
    resolvedClass,
    outputPath,
    paths.debug,
  );
  console.log(`Generated TestUp config for ${resolvedClass} at ${configPath}`);
  await runTestUpConfig(paths, configPath);
  console.log(`Class results should be written to: ${resolvedOutput}`);
}

async function runStartupScript(paths, userScript) {
  await deploy(paths);
  const resolvedScript = ensureAbsolute(userScript || process.env.STARTUP_RUBY || '');
  ensureExists(resolvedScript, 'Startup Ruby script');
  const wrapperPath = path.join(os.tmpdir(), `aicabinets-startup-${Date.now()}.rb`);
  const wrapperContent = renderWrapper(resolvedScript);
  fs.writeFileSync(wrapperPath, wrapperContent, 'utf8');
  console.log(`Executing ${resolvedScript} via wrapper ${wrapperPath}`);
  await runSketchUp(paths.sketchupExe, ['-RubyStartup', wrapperPath], paths.debug);
}

async function main() {
  const { command, flags } = parseArgs(process.argv);
  const paths = resolvedPaths(flags);

  try {
    switch (command) {
      case 'deploy':
        await deploy(paths);
        break;
      case 'testup:all':
        await runTestUpAll(paths);
        break;
      case 'testup:config':
        await runTestUpConfig(paths, flags.config);
        break;
      case 'testup:class':
        await runTestUpClass(paths, flags.class, flags.output);
        break;
      case 'sketchup:run':
        await runStartupScript(paths, flags.script);
        break;
      default:
        console.error('Usage: node script/sketchup.js [deploy|testup:all|testup:config|testup:class|sketchup:run] [--debug] [--exe <path>] [--plugins <path>] [--tests <path>] [--config <path>] [--class <TestUpClass>] [--output <results.json>] [--script <path>]');
        process.exitCode = 1;
    }
  } catch (error) {
    console.error(error.message);
    process.exitCode = 1;
  }
}

main();
