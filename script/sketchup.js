#!/usr/bin/env node
const fs = require('fs');
const os = require('os');
const path = require('path');
const { spawn } = require('child_process');

const repoRoot = path.resolve(__dirname, '..');
const sketchupVersion = process.env.SKETCHUP_VERSION || '2026';
const defaultExeBase = process.env.ProgramFiles || 'C:\\Program Files';
const defaultExe = path.win32.join(
  defaultExeBase,
  'SketchUp',
  `SketchUp ${sketchupVersion}`,
  'SketchUp',
  'SketchUp.exe',
);
const defaultPlugins = process.env.APPDATA
  ? path.win32.join(process.env.APPDATA, 'SketchUp', `SketchUp ${sketchupVersion}`, 'SketchUp', 'Plugins')
  : null;

function parseArgs(argv) {
  const args = { flags: {} };
  const [, , command, ...rest] = argv;
  args.command = command;

  for (let i = 0; i < rest.length; i += 1) {
    const token = rest[i];
    if (!token.startsWith('--')) continue;
    const key = token.slice(2);
    const next = rest[i + 1];
    if (next && !next.startsWith('--')) {
      args.flags[key] = next;
      i += 1;
    } else {
      args.flags[key] = true;
    }
  }
  return args;
}

function ensureAbsolute(inputPath) {
  if (path.isAbsolute(inputPath) || path.win32.isAbsolute(inputPath)) {
    return inputPath;
  }
  return path.resolve(repoRoot, inputPath);
}

function ensureExists(targetPath, label) {
  if (!targetPath) {
    throw new Error(`Missing ${label}. Set the related environment variable to override the default.`);
  }
  if (!fs.existsSync(targetPath)) {
    throw new Error(`${label} not found: ${targetPath}`);
  }
}

function logDebug(enabled, message) {
  if (enabled) {
    console.log(`[debug] ${message}`);
  }
}

function copyExtension(pluginsDir, debug) {
  logDebug(debug, `Ensuring Plugins directory exists: ${pluginsDir}`);
  fs.mkdirSync(pluginsDir, { recursive: true });

  const registrarSrc = path.join(repoRoot, 'aicabinets.rb');
  const registrarDst = path.join(pluginsDir, 'aicabinets.rb');
  ensureExists(registrarSrc, 'aicabinets.rb');

  logDebug(debug, `Copying registrar to ${registrarDst}`);
  fs.copyFileSync(registrarSrc, registrarDst);

  const supportSrc = path.join(repoRoot, 'aicabinets');
  const supportDst = path.join(pluginsDir, 'aicabinets');
  ensureExists(supportSrc, 'aicabinets/');

  logDebug(debug, `Refreshing support folder at ${supportDst}`);
  fs.rmSync(supportDst, { recursive: true, force: true });
  fs.cpSync(supportSrc, supportDst, { recursive: true });
}

function runSketchUp(exePath, args, debug, { capture = false } = {}) {
  return new Promise((resolve, reject) => {
    logDebug(debug, `Launching SketchUp: ${exePath} ${args.map((arg) => JSON.stringify(arg)).join(' ')}`);

    const child = spawn(exePath, args, {
      stdio: capture ? ['ignore', 'pipe', 'pipe'] : 'inherit',
    });

    const stdoutChunks = [];
    const stderrChunks = [];

    if (capture && child.stdout && child.stderr) {
      child.stdout.on('data', (data) => {
        stdoutChunks.push(data);
        process.stdout.write(data);
      });
      child.stderr.on('data', (data) => {
        stderrChunks.push(data);
        process.stderr.write(data);
      });
    }

    child.on('error', (error) => {
      reject(new Error(`Failed to launch SketchUp: ${error.message}`));
    });

    child.on('exit', (code) => {
      const stdout = Buffer.concat(stdoutChunks).toString();
      const stderr = Buffer.concat(stderrChunks).toString();

      if (code !== 0) {
        reject(new Error(`SketchUp exited with status ${code}\n${stdout}${stderr ? `\n${stderr}` : ''}`));
      } else {
        resolve({ stdout, stderr });
      }
    });
  });
}

function resolvedPaths(flags) {
  const debug = Boolean(flags.debug);
  const sketchupExe = flags.exe ? ensureAbsolute(flags.exe) : (process.env.SKETCHUP_EXE || defaultExe);
  const pluginsDir = flags.plugins ? ensureAbsolute(flags.plugins) : (process.env.SKETCHUP_PLUGINS_DIR || defaultPlugins);
  const testsRoot = flags.tests ? ensureAbsolute(flags.tests) : (process.env.AI_CABINETS_TESTS || path.join(repoRoot, 'tests', 'AI Cabinets'));

  return { sketchupExe, pluginsDir, testsRoot, debug };
}

function renderWrapper(startupScript) {
  const escapedScript = startupScript.replace(/\\/g, '\\\\');
  return `# Auto-generated by script/sketchup.js

require 'fileutils'

module AICabinets
  module StartupConsoleCapture
    STDOUT_ENV = 'AI_CABINETS_RUBY_CONSOLE_LOG'
    STDERR_ENV = 'AI_CABINETS_RUBY_CONSOLE_ERR_LOG'

    class ConsoleTee
      def initialize(primary, secondary)
        @primary = primary
        @secondary = secondary
      end

      def write(*args)
        result = @primary.respond_to?(:write) ? @primary.write(*args) : nil
        @secondary.write(*args)
        result
      end

      def puts(*args)
        result = @primary.respond_to?(:puts) ? @primary.puts(*args) : nil
        @secondary.puts(*args)
        result
      end

      def print(*args)
        result = @primary.respond_to?(:print) ? @primary.print(*args) : nil
        @secondary.print(*args)
        result
      end

      def flush
        @primary.flush if @primary.respond_to?(:flush)
        @secondary.flush if @secondary.respond_to?(:flush)
        nil
      end

      def sync=(value)
        @primary.sync = value if @primary.respond_to?(:sync=)
        @secondary.sync = value if @secondary.respond_to?(:sync=)
        value
      end

      def sync
        @primary.respond_to?(:sync) ? @primary.sync : nil
      end
    end

    module_function

    def configure
      stdout_logger = prepare_log(sanitized_env(STDOUT_ENV))
      stderr_logger = prepare_log(sanitized_env(STDERR_ENV))
      if stdout_logger
        $stdout = ConsoleTee.new($stdout, stdout_logger)
        $stdout.sync = true if $stdout.respond_to?(:sync=)
      end
      if stderr_logger
        $stderr = ConsoleTee.new($stderr, stderr_logger)
        $stderr.sync = true if $stderr.respond_to?(:sync=)
      end
    rescue => error
      warn("Ruby console capture setup failed: #{error.message}")
    end

    def sanitized_env(key)
      value = ENV[key]
      value && !value.strip.empty? ? value.strip : nil
    end

    def prepare_log(path)
      return nil unless path

      FileUtils.mkdir_p(File.dirname(path))
      io = File.open(path, 'w', encoding: Encoding::UTF_8)
      io.sync = true if io.respond_to?(:sync=)
      at_exit do
        begin
          io.flush
          io.close unless io.closed?
        rescue StandardError
          # ignore cleanup failures
        end
      end
      io
    rescue => error
      warn("Unable to prepare Ruby console log #{path}: #{error.message}")
      nil
    end
  end
end

AICabinets::StartupConsoleCapture.configure

def close_without_save
  if defined?(Sketchup.close_active_model)
    Sketchup.close_active_model(false)
  else
    model = Sketchup.active_model
    if model&.respond_to?(:close)
      model.close(false)
    end
  end
rescue => error
  STDERR.puts("Close failure: #{error.message}")
  error.backtrace.each { |line| STDERR.puts(line) }
end

def save_dirty_model_to_temp
  model = Sketchup.active_model
  return nil unless model&.respond_to?(:modified?)
  return nil unless model.modified?
  temp_path = File.join(
    Sketchup.temp_dir,
    "aicabinets-autosave-#{Process.pid}-#{Time.now.to_i}.skp"
  )
  if model.save(temp_path)
    temp_path
  end
rescue => error
  STDERR.puts("Temp save failure: #{error.message}")
  error.backtrace.each { |line| STDERR.puts(line) }
  nil
end

def cleanup_temp_file(path)
  return unless path
  File.delete(path) if File.exist?(path)
rescue => error
  STDERR.puts("Temp delete failure: #{error.message}")
  error.backtrace.each { |line| STDERR.puts(line) }
end

temp_save_path = nil

begin
  load '${escapedScript}'
rescue => error
  STDERR.puts("Script error: #{error.message}")
  error.backtrace.each { |line| STDERR.puts(line) }
ensure
  temp_save_path ||= save_dirty_model_to_temp
end

begin
  temp_save_path ||= save_dirty_model_to_temp
  close_without_save
ensure
  cleanup_temp_file(temp_save_path)
  Sketchup.quit
end
`;
}

function parseConfigHints(configPath) {
  try {
    const content = fs.readFileSync(configPath, 'utf8');
    const scalar = (label) => {
      const match = content.match(new RegExp(`^${label}:\\s*(.+)$`, 'mi'));
      return match ? match[1].trim() : null;
    };
    return {
      output: scalar('Output'),
      log: scalar('LogPath'),
      errorLog: scalar('ErrorLogPath'),
    };
  } catch (error) {
    // Best-effort logging only.
  }
  return {};
}

async function deploy(paths) {
  ensureExists(paths.sketchupExe, 'SketchUp executable');
  ensureExists(paths.pluginsDir, 'SketchUp Plugins directory (set SKETCHUP_PLUGINS_DIR or APPDATA)');
  copyExtension(paths.pluginsDir, paths.debug);
  console.log(`Deployed AI Cabinets to ${paths.pluginsDir}`);
}

async function runTestUpAll(paths, outputPath) {
  const {
    configPath,
    resolvedOutput,
    consoleLogPath,
    consoleErrPath,
  } = generateAllConfig(paths.testsRoot, outputPath, paths.debug);
  console.log(`Generated TestUp config for the full suite at ${configPath}`);

  const previousStdoutCapture = process.env.AI_CABINETS_RUBY_CONSOLE_LOG;
  const previousStderrCapture = process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG;
  process.env.AI_CABINETS_RUBY_CONSOLE_LOG = consoleLogPath;
  process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG = consoleErrPath;
  try {
    await runTestUpConfig(paths, configPath);
  } finally {
    if (previousStdoutCapture === undefined) {
      delete process.env.AI_CABINETS_RUBY_CONSOLE_LOG;
    } else {
      process.env.AI_CABINETS_RUBY_CONSOLE_LOG = previousStdoutCapture;
    }
    if (previousStderrCapture === undefined) {
      delete process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG;
    } else {
      process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG = previousStderrCapture;
    }
  }
  console.log(`Full suite results should be written to: ${resolvedOutput}`);
  if (fs.existsSync(consoleLogPath)) {
    console.log(`Ruby console log saved to: ${consoleLogPath}`);
  } else {
    console.warn(`Ruby console log missing: ${consoleLogPath}`);
  }
  if (fs.existsSync(consoleErrPath)) {
    console.log(`Ruby console stderr saved to: ${consoleErrPath}`);
  } else {
    console.warn(`Ruby console stderr missing: ${consoleErrPath}`);
  }
}

async function runTestUpConfig(paths, configPath, captureTargets = {}) {
  await deploy(paths);
  const resolvedConfig = ensureAbsolute(configPath || process.env.TESTUP_CONFIG || '');
  ensureExists(resolvedConfig, 'TestUp config file');
  const { output, log: logPath, errorLog } = parseConfigHints(resolvedConfig);
  if (output) {
    console.log(`Config output path: ${output}`);
  }
  if (logPath) {
    console.log(`Config Ruby console log path: ${logPath}`);
  }
  if (errorLog && errorLog !== logPath) {
    console.log(`Config Ruby console error log path: ${errorLog}`);
  }
  const arg = `TestUp:CI:Config: ${resolvedConfig}`;
  console.log(`Running TestUp config from ${resolvedConfig}`);
  const result = await runSketchUp(
    paths.sketchupExe,
    ['-RubyStartupArg', arg],
    paths.debug,
    { capture: true },
  );
  if (captureTargets.consoleLog) {
    fs.mkdirSync(path.dirname(captureTargets.consoleLog), { recursive: true });
    fs.writeFileSync(captureTargets.consoleLog, result.stdout || '', 'utf8');
    console.log(`Ruby console log saved to: ${captureTargets.consoleLog}`);
  }
  if (captureTargets.consoleErr) {
    fs.mkdirSync(path.dirname(captureTargets.consoleErr), { recursive: true });
    fs.writeFileSync(captureTargets.consoleErr, result.stderr || '', 'utf8');
    console.log(`Ruby console stderr saved to: ${captureTargets.consoleErr}`);
  }
  if (output) {
    console.log(`Results should be written to: ${output}`);
  }
  if (logPath) {
    console.log(`Ruby console log should be written to: ${logPath}`);
  }
  if (errorLog && errorLog !== logPath) {
    console.log(`Ruby console error log should be written to: ${errorLog}`);
  }
}

function generateTestupConfig(testsRoot, options = {}) {
  ensureExists(testsRoot, 'AI Cabinets TestUp suite');

  const safeName = options.safeName || 'suite';
  const timestamp = Date.now();
  const configPath = path.join(os.tmpdir(), `aicabinets-${safeName}-${timestamp}.yml`);
  const resolvedOutput = ensureAbsolute(
    options.outputPath || path.join(repoRoot, 'dist', `testup-${safeName}-results.json`),
  );
  const consoleLogPath = ensureAbsolute(path.join(repoRoot, 'dist', `testup-${safeName}-ruby-console.log`));
  const consoleErrPath = ensureAbsolute(path.join(repoRoot, 'dist', `testup-${safeName}-ruby-errors.log`));

  fs.mkdirSync(path.dirname(resolvedOutput), { recursive: true });
  fs.mkdirSync(path.dirname(consoleLogPath), { recursive: true });
  fs.mkdirSync(path.dirname(consoleErrPath), { recursive: true });
  fs.rmSync(consoleLogPath, { recursive: true, force: true });
  fs.rmSync(consoleErrPath, { recursive: true, force: true });

  const normalizeForYaml = (value) => value.replace(/\\/g, '/');
  const lines = [
    `Path: "${normalizeForYaml(testsRoot)}"`,
    `Output: "${normalizeForYaml(resolvedOutput)}"`,
  ];
  if (Array.isArray(options.tests) && options.tests.length > 0) {
    lines.push('Tests:');
    options.tests.forEach((test) => {
      lines.push(`  - ${test}`);
    });
  }
  lines.push('');

  fs.writeFileSync(configPath, lines.join('\n'), 'utf8');
  logDebug(options.debug, `Generated ${options.description || 'TestUp'} config at ${configPath}`);
  logDebug(options.debug, `Results will be written to ${resolvedOutput}`);

  return {
    configPath,
    resolvedOutput,
    consoleLogPath,
    consoleErrPath,
  };
}

function generateClassConfig(testsRoot, testClass, outputPath, debug) {
  if (!testClass) {
    throw new Error('Missing required --class <TestUpClassName> argument.');
  }
  const safeName = testClass.replace(/[^A-Za-z0-9_-]/g, '_');
  return generateTestupConfig(testsRoot, {
    safeName,
    tests: [`${testClass}#`],
    outputPath,
    debug,
    description: `${testClass} class`,
  });
}

function generateAllConfig(testsRoot, outputPath, debug) {
  return generateTestupConfig(testsRoot, {
    safeName: 'all',
    outputPath,
    debug,
    description: 'full suite',
  });
}

async function runTestUpClass(paths, testClass, outputPath) {
  const resolvedClass = testClass || process.env.TESTUP_CLASS;
  const {
    configPath,
    resolvedOutput,
    consoleLogPath,
    consoleErrPath,
  } = generateClassConfig(
    paths.testsRoot,
    resolvedClass,
    outputPath,
    paths.debug,
  );
  console.log(`Generated TestUp config for ${resolvedClass} at ${configPath}`);
  const previousStdoutCapture = process.env.AI_CABINETS_RUBY_CONSOLE_LOG;
  const previousStderrCapture = process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG;
  process.env.AI_CABINETS_RUBY_CONSOLE_LOG = consoleLogPath;
  process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG = consoleErrPath;
  try {
    await runTestUpConfig(paths, configPath);
  } finally {
    if (previousStdoutCapture === undefined) {
      delete process.env.AI_CABINETS_RUBY_CONSOLE_LOG;
    } else {
      process.env.AI_CABINETS_RUBY_CONSOLE_LOG = previousStdoutCapture;
    }
    if (previousStderrCapture === undefined) {
      delete process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG;
    } else {
      process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG = previousStderrCapture;
    }
  }
  console.log(`Class results should be written to: ${resolvedOutput}`);
  if (fs.existsSync(consoleLogPath)) {
    console.log(`Ruby console log saved to: ${consoleLogPath}`);
  } else {
    console.warn(`Ruby console log missing: ${consoleLogPath}`);
  }
  if (fs.existsSync(consoleErrPath)) {
    console.log(`Ruby console stderr saved to: ${consoleErrPath}`);
  } else {
    console.warn(`Ruby console stderr missing: ${consoleErrPath}`);
  }
}

async function runStartupScript(paths, userScript) {
  await deploy(paths);
  const resolvedScript = ensureAbsolute(userScript || process.env.STARTUP_RUBY || '');
  ensureExists(resolvedScript, 'Startup Ruby script');
  const timestamp = Date.now();
  const wrapperPath = path.join(os.tmpdir(), `aicabinets-startup-${timestamp}.rb`);
  const wrapperContent = renderWrapper(resolvedScript);
  fs.writeFileSync(wrapperPath, wrapperContent, 'utf8');
  const safeScriptName = path.basename(resolvedScript).replace(/[^A-Za-z0-9_-]/g, '_') || 'script';
  const logDir = path.join(repoRoot, 'dist');
  fs.mkdirSync(logDir, { recursive: true });
  const consoleLogPath = path.join(logDir, `sketchup-run-${safeScriptName}-${timestamp}-ruby-console.log`);
  const consoleErrPath = path.join(logDir, `sketchup-run-${safeScriptName}-${timestamp}-ruby-errors.log`);
  const previousStdoutCapture = process.env.AI_CABINETS_RUBY_CONSOLE_LOG;
  const previousStderrCapture = process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG;
  process.env.AI_CABINETS_RUBY_CONSOLE_LOG = consoleLogPath;
  process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG = consoleErrPath;
  console.log(`Executing ${resolvedScript} via wrapper ${wrapperPath}`);
  try {
    await runSketchUp(paths.sketchupExe, ['-RubyStartup', wrapperPath], paths.debug);
  } finally {
    if (previousStdoutCapture === undefined) {
      delete process.env.AI_CABINETS_RUBY_CONSOLE_LOG;
    } else {
      process.env.AI_CABINETS_RUBY_CONSOLE_LOG = previousStdoutCapture;
    }
    if (previousStderrCapture === undefined) {
      delete process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG;
    } else {
      process.env.AI_CABINETS_RUBY_CONSOLE_ERR_LOG = previousStderrCapture;
    }
  }
  if (fs.existsSync(consoleLogPath)) {
    console.log(`Ruby console log saved to: ${consoleLogPath}`);
  } else {
    console.warn(`Ruby console log missing: ${consoleLogPath}`);
  }
  if (fs.existsSync(consoleErrPath)) {
    console.log(`Ruby console stderr saved to: ${consoleErrPath}`);
  } else {
    console.warn(`Ruby console stderr missing: ${consoleErrPath}`);
  }
}

async function main() {
  const { command, flags } = parseArgs(process.argv);
  const paths = resolvedPaths(flags);

  try {
    switch (command) {
      case 'deploy':
        await deploy(paths);
        break;
      case 'testup:all':
        await runTestUpAll(paths, flags.output);
        break;
      case 'testup:config':
        await runTestUpConfig(paths, flags.config);
        break;
      case 'testup:class':
        await runTestUpClass(paths, flags.class, flags.output);
        break;
      case 'sketchup:run':
        await runStartupScript(paths, flags.script);
        break;
      default:
        console.error('Usage: node script/sketchup.js [deploy|testup:all|testup:config|testup:class|sketchup:run] [--debug] [--exe <path>] [--plugins <path>] [--tests <path>] [--config <path>] [--class <TestUpClass>] [--output <results.json>] [--script <path>]');
        process.exitCode = 1;
    }
  } catch (error) {
    console.error(error.message);
    process.exitCode = 1;
  }
}

main();
